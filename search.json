[{"title":"SpringBoot使用RedisTemplate来操作Redis","url":"/2023/10/31/java/SpringBoot%E4%BD%BF%E7%94%A8RedisTemplate%E6%9D%A5%E6%93%8D%E4%BD%9CRedis/","content":"RedisTemplate 是 Spring Framework 中用于与 Redis 数据库进行交互的核心类之一。它提供了一种方便的方式来执行各种 Redis 操作，包括数据存储、读取、更新和删除等。和 Jedis、Lettuce类似，它们都是与 Redis 数据库进行交互的 Java 客户端库。\n\n\n\n\n自定义RedisTemplateSpringBoot默认提供的是    RedisTemplate&lt;Object,Object&gt; ，可以在 RedisAutoConfiguration 中查看详情，不适合日常使用。因此我们需要自定义一个 RedisTemplate 并注入到容器中。\n@Configurationpublic class RedisConfig &#123;    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) &#123;        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();        template.setConnectionFactory(connectionFactory);        // 使用Jackson2JsonRedisSerializer来序列化和反序列化Redis的值        Jackson2JsonRedisSerializer&lt;Object&gt; jacksonSerializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class);        // 如果直接使用Jackson2JsonRedisSerializer 获取存储的对象则会变为LinkedHashMap,添加ObjectMapper可解决        ObjectMapper objectMapper = new ObjectMapper();                /**         * 配置 Jackson ObjectMapper 的默认类型信息处理方式         * objectMapper.getPolymorphicTypeValidator():这是一个类型验证器，用于验证多态类型的完整性和安全性。         * ObjectMapper.DefaultTyping.NON_FINAL:类型信息的默认处理方式         * JsonTypeInfo.As.PROPERTY:类型信息将作为 JSON 属性包含在对象中         */        objectMapper.activateDefaultTyping(objectMapper.getPolymorphicTypeValidator(), ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);        //Jackson 会在反序列化时，如果遇到未知的属性（即 JSON 数据中包含了 Java 对象中没有的属性），抛出 UnrecognizedPropertyException 异常        //忽略未知属性而不抛出异常        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);        jacksonSerializer.setObjectMapper(objectMapper);        //key采用StringRedisSerializer        template.setKeySerializer(new StringRedisSerializer());        //value采用jacksonSerializer        template.setValueSerializer(jacksonSerializer);        return template;    &#125;&#125;\n\n\n\n创建工具类 RedisUtil有了 RedisTemplate 后就可以简单的操作Redis数据库了。为了方便，我们可以创建一个工具类，封装一些简单的操作。\npublic class RedisUtil &#123;    @Autowired    private RedisTemplate&lt;String, Object&gt; redisTemplate;    // 存储数据    public void set(String key, Object value) &#123;        redisTemplate.opsForValue().set(key, value);    &#125;    // 获取数据    public Object get(String key) &#123;        return redisTemplate.opsForValue().get(key);    &#125;    // 设置过期时间（秒）    public boolean expire(String key, long timeout) &#123;        return redisTemplate.expire(key, timeout, TimeUnit.SECONDS);    &#125;    // 删除数据    public boolean delete(String key) &#123;        return redisTemplate.delete(key);    &#125;&#125;\n","categories":["java"],"tags":["Redis","RedisTemplate"]},{"title":"Lecture 1:Introduction of Deep Learning","url":"/2023/09/26/DL/Lecture-1-Introduction-of-Deep-Learning/","content":"Lecture 1:Introduction of Deep Learning一、机器学习Machine Learning ≈ Let Machine looking for Function\n机器学习其实就是让机器不断学习从而找到输入数据和输出结果的函数映射。然后使用这个函数去预测未来！！！\n这些函数大致可以分为以下三种类型:\n\nRegression ：the function outputs a scalar.\n\nClassification ：given options,the function outputs the correct one.\n\nStructured learning ：create something with structure(image,document,etc.)\n\n\n\n\n机器学习的步骤\nStep1：Function with Unknown Parameters\n\n首先根据 training data，推测一个带有未知参数的函数，这个函数就是模型(Model)。当然，这个函数越拟合 training data 越好。\n\nStep2：Define Loss from Training Data\n\n\n定义一个损失函数，它的输出结果代表着这一组未知参数好不好。对 training data 的每一个 sample 计算loss，loss为实际值(y_hat)与预测值之间的差值。最终计算所有loss的平均值得到 LOSS ，即 training data 在这个损失函数下的损失。\n\nStep3：Optimization\n\n根据 Optimization 算法找出使得 LOSS 足够小的一组未知参数，以Gradient Descent 算法为例。将所有的未知参数组成一个向量 θ。对 θ 计算gradient得到向量 g 。然后向 g 的反方向更新 θ 。\n\n η ：learning rate。它是一个自己给定的参数。这种自己给定的参数在机器学习称之为 hyperparameter 。\n在实际中，一般将训练数据分成一个个batch，每次用一个batch来计算gradient。每一次更新 θ 就是一次 update ，所有的batch全部计算gradient之后就叫一次 epoch 。\n\n\n\n\n二、深度学习深度学习是机器学习的一个子分支，他是让机器以一种类神经网络的方式进行学习。即将每一个 activation function作为一个神经元，每一层的输出作为下一层的输入，形成的类似于神经网络的model。\n\n\n","categories":["深度学习"],"tags":["Machine Learning","Deep Learning"]},{"title":"Hexo相关问题及优化","url":"/2023/06/16/tool/Hexo%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%8F%8A%E4%BC%98%E5%8C%96/","content":"使用了Hexo一段时间，发现了一些问题，特在此记录。\n\n\n分类和标签Hexo 项目初始状态下并没有 Categories（分类）、Tags（标签）、Links（友链）、About（关于）等页面，需要自己手动创建。\n\n分类\n\nhexo new page categories\n\n标签\n\nhexo new page tags\n\n执行上述命令后，Hexo会创建分类和标签页面。你在 Front Matter 中设置的分类会在其中显示。\n\n关于\n\nhexo new page about\n\n此时你可以在Hexo项目 /source/about/index.md 中填写关于页面。\n\n\n自定义域名如果你跟我一样部署到Github上，且不想用默认的 &lt;username&gt;.github.io 域名，则可以自定义域名。\n\n在域名注册商 or 托管服务商中添加一条 CNAME 记录\n\n\nCNAME 记录把域名解析到另一个域名\n\n\n\n管理自定义域\n\nGithub文档：管理自定义域\n进入自己站点仓库的 Settings | Page  页面，输入自己的域名，强制开启HTTPS。\n\n查看 Source\n\nGithub Actions，填写完域名后无需其它操作。\nDeploy from a branch，它会创建 CNAME 文件，并提交到源分支的根目录。\n注意：使用Gtihub Actions自动构建时会重新生成站点，该 CNAME 文件会消失，自定义域名失败。故应该在Hexo项目 /source 目录下创建 CNAME 文件，这样每次提交Hexo项目并自动构建后 CNAME 文件还会在站点中。\nCNAME 文件内容：\nyour domain\n\n\n\n自动构建博客更新时间BUGgit 在推送更新时，并不记录保存文件的访问时间、修改时间等元信息。又因为如果没有在 front-matter 中指定 updated，Hexo 会默认使用文件的最后修改时间作为文章的更新时间，所以会出现 CI 构建后所有文章的更新时间都变成了此次构建的时间。\n在自动部署文件中添加以下代码：该条命令会将文件的最后修改时间修改为 Git 仓库中文件的最后提交时间，即文章的更新时间。\n大白话：如果不干预，那么文件最后的修改时间就是此次的构建时间，从而出错。文件的最后修改时间必须和Git仓库中最后的提交时间一致才是正确的。\n- name: Restore file modification time   run: find source -name &#x27;*.md&#x27; | while read file; do touch -d &quot;$(git log -1 --format=&quot;@%ct&quot; &quot;$file&quot;)&quot; &quot;$file&quot;; done\n\n设定Checkout的参数 fetch-depth: 0，因为 0 表示获取所有分支和标签的所有历史记录。\n- name: Checkout        uses: actions/checkout@master        with:          fetch-depth: 0\n\n","categories":["工具"],"tags":["Hexo"]},{"title":"Idea安装及常用配置","url":"/2023/06/15/tool/Idea%E5%AE%89%E8%A3%85%E5%8F%8A%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/","content":"今天重装了一下Idea，很多小细节忘了还搞了很久。故在此记录它的安装及常用配置，以免后续重装时浪费时间，也给还没装过的新手以参考。\n\n\n\n\n安装选择你想要的版本，一路next。\n\n\n破解\n注：此方法适用于 JetBrains 全家桶\n\n\n下载大神的文件\n\n随便选一个延迟比较低的链接进去，下载顶部的 jetbra.zip 压缩包。其中 readme.txt 中有详细说明！\n\n修改安装路径bin文件下的 idea64.exe.vmoptions，添加以下内容：\n\n# 注意路径中是反斜杠-javaagent:yourpath\\ja-netfilter.jar=jetbrains#以下高版本需要,readme.txt中有说明--add-opens=java.base/jdk.internal.org.objectweb.asm=ALL-UNNAMED--add-opens=java.base/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED\n\n\n在网页中找到对应软件的激活码\n\n直接输入激活\n\n\n配置Maven在File | Settings | Build, Execution, Deployment | Build Tools | Maven进行以下设置：\n\nmaven路径：yourpath/Maven/apache-maven-3.5.4\nmaven配置文件路径：yourpath\\Maven\\apache-maven-3.5.4\\conf\\settings.xml\nmaven仓库路径：yourpath\\Maven\\your-repository\n\n👉 Tip：在 File | Settings | Appearance &amp; Behavior | Path Variables 下有一个 MAVEN_REPOSITORY 项（如果没有就不用管了），最好将值改为自己的仓库路径。\nTomcatFile | Settings | Build, Execution, Deployment | Application Servers\n添加Tomcat Local 服务器\n\n以下路径注意要根据你自己的Tomcat路径进行修改！\n\n\nGit设置Git路径：yourpath\\Git\\bin\\git.exe，点击Test按钮出现Git版本即代表成功。\nGithub创建GitHub Token进行登录。为保证成功，请该Token勾选所有权限。\n\n该token只会出现一次，为避免忘记，请将其保存。若遗忘重新生成即可👌🏻。\n\n其它配置其它个性化设置可以请自行根据需要设置。\n备份配置 最后可将上述配置导出备份。具体步骤为：\n\n","categories":["工具"],"tags":["Idea","配置"]},{"title":"maven的三种打包方式--jar,pom,war","url":"/2023/08/23/java/maven%E7%9A%84%E4%B8%89%E7%A7%8D%E6%89%93%E5%8C%85%E6%96%B9%E5%BC%8F--jar,pom,war/","content":"maven有三种打包方式，分别是jar、pom、war。下面将分析它们分别应该在什么场景下使用。\n\n\njar将工程打包成一个jar文件，本质上是一个压缩包。里面可能包含了一些class文件，一般用于给其他工程进行引用。\nwar将工程打包成一个war包，用于在服务器上进行发布。\npompom是maven依赖文件，一般父项目的打包形式为 pom ，用于为子项目进行依赖管理。\n","categories":["java"],"tags":["maven","java"]},{"title":"使用jackson进行json的序列化与反序列化","url":"/2023/10/28/java/%E4%BD%BF%E7%94%A8jackson%E8%BF%9B%E8%A1%8Cjson%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","content":"Jackson是一种广泛使用的JSON库，可以轻松地将Java对象转换为JSON数据和将JSON数据转换为Java对象。\nSpring Boot默认集成了Jackson作为其JSON序列化和反序列化库，不需要特别配置Jackson，它已经包含在Spring Boot的启动器依赖中，因此在Spring Boot应用中，您可以直接使用Jackson进行JSON操作，而不需要额外的依赖或配置。\n\n\nObjectMapperObjectMapper 是 Jackson JSON 处理库中的一个核心类，它用于执行 JSON 数据和 Java 对象之间的转换（序列化和反序列化）。\n以下是一些关于 ObjectMapper 的常见用法和方法：\n\n创建 ObjectMapper 实例 \nimport com.fasterxml.jackson.databind.ObjectMapper;ObjectMapper objectMapper = new ObjectMapper();\n\n将 Java 对象序列化为 JSON字符串 \nString jsonString = objectMapper.writeValueAsString(javaObject);\n\n将 JSON 反序列化为 Java 对象\nJavaClass javaObject = objectMapper.readValue(jsonString, JavaClass.class);\n\n其他设置和配置： ObjectMapper 可以用于配置各种序列化和反序列化选项。\n\nSerializationFeature 和 DeserializationFeature:\n\nSerializationFeature 用于配置 JSON 序列化选项，例如日期格式、空值处理等。\nDeserializationFeature 用于配置 JSON 反序列化选项，例如忽略未知属性、空字符串转换为 null 等。\nobjectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);\n\n\n配置日期序列化的格式\n\nSimpleDateFormat format = new SimpleDateFormat(&quot;yy.MM.dd&quot;);objectMapper.setDateFormat(format);\n\n\nJsonInclude用于设置序列化时包含或排除的属性\n\n objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); // 只包含非空属性\n\n\nactivateDefaultTyping 方法可以用于配置多态类型的序列化和反序列化:\n\n objectMapper.activateDefaultTyping(objectMapper.getPolymorphicTypeValidator(), ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);\n\n","categories":["java"],"tags":["json","jackson","ObjectMapper"]},{"title":"Node.js的安装及环境配置","url":"/2023/09/25/tool/Node-js%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","content":"本文主要介绍了Node.js的安装及环境配置。\n\n\n1. 安装Node.js的安装比较简单，官网地址为 https://nodejs.org/en 。安装过程中需要注意的地方如下(以18.18.0 LTS版本为例)：\n\n自定义安装位置\n\n这个不再赘述，选择你想要安装的位置。\n\n选择安装内容\n\n前三个都是必须的，第四个是在线文档，可以不用安装。最后一个是添加环境变量，新版本可以自动添加，此时你也可以不选择后续手动添加。\n\n\n安装额外依赖\n\n不用选择，如果真的缺少可以自己手动安装。\n\n以上就是Node.js的安装过程，除了上述一些需要注意的地方，其他的都可以一路Next。安装成功后以管理员身份打开 CMD ，使用如下命令判断是否安装成功。若如下图所示，则安装成功。\n\n\n\n\n2. 修改全局模块路径和缓存路径Node.js的默认全局模块路径和缓存路径分别是：\nC:\\Users\\用户名\\AppData\\Roaming\\npmC:\\Users\\用户名\\AppData\\Local\\npm-cache\n建议修改便于管理，同时也可以减少C盘的占用。\n首先需要在Node.js安装目录下新建 node_global 和 node_cache 两个文件夹。\n然后使用如下命令修改：\nnpm config set prefix &quot;D:\\tool\\NodeJs\\node_global&quot;npm config set cache &quot;D:\\tool\\NodeJs\\node_cache&quot;\n\n\n\n3. 设置淘宝镜像站由于npm官方网站在国外，设置淘宝镜像站可以提升从官方拉取模块的速度。\nnpm config set  registry  https://registry.npmmirror.com/\n\n\n\n4. 修改环境变量因为修改了全局模块路径和缓存路径，所以需要修改一下环境变量。\n\n修改用户变量中的Path变量，将默认的npm的路径 C:\\Users\\用户名\\AppData\\Roaming\\npm 改为：D:\\nodejs\\node_global\n\n在系统变量中配置node_global 的路径，D:\\tool\\NodeJs\\node_global\n\n\n\n\n大功告成！！！\n\n\n注意：若在VS Code中使用出现如下问题：\n\n‘npm’ is not recognized as an internal or external command,operable program or batch file.\n\n直接重启一下VS Code应该就可以了。参考回答：https://stackoverflow.com/questions/20992723/npm-is-not-recognized-as-internal-or-external-command-operable-program-or-bat\n","categories":["工具"],"tags":["Node.js","npm"]},{"title":"使用SpringBoot进行简单的文件上传","url":"/2023/10/31/java/%E4%BD%BF%E7%94%A8SpringBoot%E8%BF%9B%E8%A1%8C%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","content":"本文将介绍如何在 Spring Boot 中进行最基本的文件上传操作。\n\n\n文件上传如果要将上传文件解析为 MultipartFile 对象，通常需要使用文件解析器。在 Spring Boot 中，默认使用的是 StandardServletMultipartResolver，它会自动解析文件上传请求并将文件转换为 MultipartFile 对象。\npublic class MultipartAutoConfiguration &#123;    @Bean(        name = &#123;&quot;multipartResolver&quot;&#125;    )    @ConditionalOnMissingBean(&#123;MultipartResolver.class&#125;)    public StandardServletMultipartResolver multipartResolver() &#123;        StandardServletMultipartResolver multipartResolver = new StandardServletMultipartResolver();        multipartResolver.setResolveLazily(this.multipartProperties.isResolveLazily());        return multipartResolver;    &#125;&#125;\n\n\n创建文件上传表单 \n在前端页面中创建一个表单，允许用户选择并上传图片文件。使用  &lt;input type=&quot;file&quot;&gt; 标签来实现文件上传。\n&lt;!-- 注意enctype必须为 multipart/form-data --&gt;&lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot; &gt;    &lt;input type=&quot;submit&quot; value=&quot;Upload&quot;&gt;&lt;/form&gt;\n\n后端处理文件上传 \nimport org.springframework.web.bind.annotation.*;import org.springframework.web.multipart.MultipartFile;@RestControllerpublic class FileUploadController &#123;    @PostMapping(&quot;/upload&quot;)    public ResponseData handleFileUpload(@RequestParam(&quot;file&quot;) MultipartFile file) &#123;     //判空     if (image.isEmpty()) &#123;         // TODO 文件为空处理     &#125;     //将文件存放到服务器     //1.获取原始文件名     String originalFilename = image.getOriginalFilename();     //2.创建新文件     File file = new File(&quot;yourpath/&quot; + originalFilename);     //3.将MultipartFile对象转换为文件     try &#123;         image.transferTo(file);     &#125; catch (IOException e) &#123;         throw new RuntimeException(e);     &#125;    &#125;&#125;\n\n请替换 &quot;yourpath/&quot; 为你希望存储上传文件的实际目录。\n\n上传相关配置 \n 可按照需求配置。\n  ##文件上传配置spring:  servlet:    multipart:      #开启MultipartResolver,默认为true      enabled: true      ##设置文件上传位置      location: classpath:images/      #限制文件大小      max-file-size: 5MB      #限制整个请求的大小      max-request-size: 10MB\n\n","categories":["java"],"tags":["springboot","文件上传","MultipartFile"]},{"title":"SSH免密登录的原理和使用","url":"/2023/09/26/tool/SSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/","content":"本文将介绍SSH免密登录(利用公钥登录)的原理和使用。\n\n\n1. SSH简介SSH，即(Secure Shell)。SSH协议使用加密来保证客户端和服务器端连接的安全。\nSSH在用户认证中的使用，即SSH keys 。本文介绍其中一种认证方式——公钥登录。\n\n\n2. 利用公钥登录的原理\n\n客户端向服务器端发送连接请求，请求中携带了公钥指纹(fingerprint)\n\n服务器端根据指纹判断在 authorized_keys 中寻找相应的公钥，若找到则加密一个随机字符串发送给客户端，客户端使用私钥进行解密并将结果发送给服务器端，服务器端进行结果验证，若解密结果与初始未加密随机字符串相同，则认证成功。\n\n\n\n\n\n3. 利用公钥登录的使用\n首先删除原有的 .ssh 目录：\n\nWindows系统 .ssh 位于C:\\Users\\Administrator\\.ssh ，直接删除即可。\nLinux系统：\ncd ~ ##进入当前用户rm -r .ssh/ ##删除\n\n\n利用 ssh-keygen 生产密钥对\n\n参考文档如下：  https://www.ssh.com/academy/ssh/keygen\nssh-keygen##optional# -t 选择加密算法，默认使用RSA加密算法# -c &quot;Comment&quot; Changes the comment for a keyfile.# 其他参数请查看参考文档\n\n一直按enter就行，最终生成私钥 id_rsa 、公钥 id_rsa.pub 。\n\n\nGithub使用SSH Keys免密登录。\n\n在GitHub账户 Settings||SSH and GPG keys 中新建一个SSH key，将公钥 id_rsa.pub. 中的内容复制到其中。\n之后，在进行push等操作时就可以跳过身份认证直接进行操作了。\n\n\n此外，SSH keys还可用于其他地方，如Xshell免密登录远程服务器。除了用户认证外，SSH也广泛的应用于数据加密等。\n","categories":["工具"],"tags":["SSH","Github"]},{"title":"v2rayN及v2rayNG使用教程","url":"/2023/06/15/tool/v2rayN%E5%8F%8Av2rayNG%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","content":"本文的前提是你已经有了自建或者购买的节点。若想要自建节点可参看我写的《从零开始自建节点》。\n\n\nv2rayN\nA GUI client for Windows, support Xray core and v2fly core and others\n\n\n在Release中下载安装包，解压运行 v2rayN.exe 即用，无需安装。\n\n\n注意：第一次需要下载带有核心的压缩包\n\n\n\n导入节点\n\n你可以直接复制节点或者订阅。\n\n设置代理\n\n\n此时你已经可以愉快的上外网冲浪了！\n对于此部分的官网解释：\n\n\n我的理解：\n\nPac模式+绕过大陆 &#x3D;&#x3D;&#x3D; 国内直连，国外代理(根据脚本)\n\n此模式可以适用于大多数场景，一般不做修改，除非有特殊需求。\n\n\n自动配置系统代理+绕过大陆 &#x3D;&#x3D;&#x3D; 国内直连，国外代理\n\n自动配置系统代理+全局 &#x3D;&#x3D;&#x3D; 全部走代理\n\n\n\n其它设置\n\n\n解除UWP应用回环代理限制\n\n若开启代理后Win10UWP应用无法联网，则在此解除。\n\n\nv2rayNG\nA V2Ray client for Android, support Xray core and v2fly core\n可在Release页面或者Google Play下载。\n\n同样，此应用使用之前需要导入节点。导入之后，只需进行如下的简单配置后，就可以愉快的使用了。\n\n对于域名策略，一般保持默认即可。\n\n对于代理规则，一般选择绕过局域网及大陆地之而后代理(国内直连，国外代理)。\n\n\n\n此应用还可以实现分应用进行代理，可以自行探索！\n","categories":["工具"],"tags":["v2rayN","v2rayNG","教程"]},{"title":"使用Hexo+Github Pages搭建个人博客","url":"/2023/06/12/tool/%E4%BD%BF%E7%94%A8Hexo-Github-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","content":"很多人都有个人博客的需求，搭建博客的方法也多种多样。本文将介绍如何利用Hexo框架搭建博客，并使用Github Actions自动部署到GitHub上。\n\n\n\n\n创建Hexo项目Hexo官方文档：https://hexo.io/zh-cn/docs/\n\n前提条件：需要有Node.js环境\n\n\n安装\n\nnpm install -g hexo-cli\n\n\n创建站点\n\nhexo init &lt;folder&gt;cd &lt;folder&gt;npm install\n\n此时站点的基础框架搭建成功！接下来就可以进行简单的写作了。当然，你可以根据官方文档进行个性化修改，如更换主题等。\n\n\n部署到Github创建博客仓库\n此仓库存放生成的静态页面。\n\n仓库注意项：\n\n必须为公有仓库\n仓库名为 &lt;username&gt;.github.io\n\n一键部署\n安装 hexo-deployer-git\n\nnpm install hexo-deployer-git --save\n\n\n修改Hexo项目 _config.yaml 文件\n\ndeploy:  type: git  repo: &lt;repository url&gt; #可以是SSH或HTTPS链接  branch: [branch] #Github Pages固定分支 gh-pages\n\n\n推送到Github\n\n\n注：除非你使用令牌或 SSH 密钥认证(推荐使用)，否则你会被提示提供目标仓库的用户名和密码。\n\nhexo clean&amp;&amp;hexo deploy\n\n\n此时，你已经完成了使用Hexo搭建博客并部署到Github上的任务。\n但若感觉每次都需要重新部署太过繁琐，则可继续往后看如何使用Github Actions自动部署。\n\n\n\n\nGithub Actions自动部署\n本文使用 hexo-theme-keep 项目提供的自动部署脚本hexo-deploy-github-pages-action\n\n\n创建源码仓库\n此仓库存放博客站点的源码。最好为私有，保证安全。\n\n\n\n为避免不必要的文件上传，Hexo范例提供的 .gitignore 文件如下：\n.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/_multiconfig.yml\n\n\n创建一个有 repo 和 workflow 权限的 GitHub Token。\n\n\n\n将token添加到私有源码仓库的 Secrets\n\n\n\n在Hexo项目的 .github/workflows 目录下创建一个 xxx.yml 文件，模板如下：\n\nname: deploying Hexo project to GitHub pageson:  push:    branches:      - main # main 分支有 push 行为时就触发这个 actionjobs:  build-and-deploy:    runs-on: ubuntu-latest    steps:      - name: Checkout        uses: actions/checkout@master      - name: Build and Deploy        uses: theme-keep/hexo-deploy-github-pages-action@master # 使用专门部署 Hexo 到 GitHub pages 的 action        env:          PERSONAL_TOKEN: $&#123;&#123; secrets.HEXO_SITE &#125;&#125; # 上一步起的 secret 名          PUBLISH_REPOSITORY: &lt;username&gt;/&lt;username&gt;.github.io # 博客仓库，格式：GitHub 用户名/仓库名          BRANCH: gh-pages # 分支，填 gh-pages 就行          PUBLISH_DIR: ./public # 部署 public 目录下的文件\n\n\n至此，自动部署完成！\n\n\n\n参考文章\nkeep作者大大亲自写的自动部署教程\nHexo官方文档\n\n","categories":["工具"],"tags":["Hexo","博客","Github Pages","Github Actions"]},{"title":"从零开始自建节点","url":"/2023/06/16/tool/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E8%87%AA%E5%BB%BA%E8%8A%82%E7%82%B9/","content":"相信大家很多人都使用过购买的VPN或者订阅节点来访问外网，但我们在购买时经常被费用、速度、安全性和稳定性等问题所困扰。如何才能获得较好的体验呢？\n\n\n首先你需要明白的是：\n\n便宜的速度慢，流量少，安全性还不能保证，可能跑路。\n贵的除了贵没什么缺点，但最大的缺点就是贵！(当然，如果你很有钱，当我没说)\n\n因此，自建节点就成为了一个很好的选择。它的费用、速度、可用流量和安全性都比购买的便宜机场优秀。但缺点就是有一定的门槛，容错率比较低，一旦IP被封，拯救起来就比较麻烦，也许只能换IP或者报废。\n本文就将介绍如何从零开始使用 x-ui 面板自建节点。\n\n\n服务器首先，你需要有一台国外或者香港的服务器。不需要太好，第三方提供的VPS(虚拟专用服务器)就已足够。接下来就根据自己的预算和需求来选择VPS厂商和套餐，本文已CloudCone厂商提供的最便宜套餐为例。\n\n\n\n域名和Cloudflare(可选)\n如果你需要申请SSL证书，那么就需要用到域名和Cloudflare了。\n\n域名没有的话随便买一个域名，越便宜越好。推荐Namesilo。\nCloudflare\n注册一个账号，并将域名托管到Cloudflare。\n\n\n\n在域名注册商中将名称服务器替换为Cloudflare提供的。\n\n以Namesilo为例：进入名称服务器管理页面，删除默认的，添加Cloudflare提供的。这样就可以使用Cloudflare的DNS解析服务了。\n\n添加A记录\nA记录就是把一个域名解析到一个IP地址。\n\n将你的根域名或者此域名下的二级域名映射到服务器IP上。\n注意事项：\n\n名称为 @ 将根域名映射，建议随便填一个名称用二级域名映射。\nIP为你自己的服务器IP。\n关闭CDN！！！\n\n\n\n\n部署x-ui面板\n原项目地址：https://github.com/vaxilu/x-ui\n二次开发地址：https://github.com/FranzKafkaYu/x-ui\n\n安装or更新bash &lt;(curl -Ls https://raw.githubusercontent.com/vaxilu/x-ui/master/install.sh)\n此时你可以通过http://ip:port/ 访问x-ui面板。如已将某个域名解析到该服务器IP，则可用域名替代ip。\n\nip为你的服务器IP\nport为x-ui端口号\n\nSSL证书申请(可选)\nSSL 证书使得网站能够从 HTTP 转到更加安全的 HTTPS。\n\n脚本内置SSL证书申请功能，使用该脚本申请证书，需满足以下条件:\n\n知晓Cloudflare 注册邮箱\n知晓Cloudflare Global API Key\n\n登录之后进入API令牌页面，输入密码查看Global API Key\n\n域名已通过cloudflare进行解析到当前服务器\n\n申请完成后，证书安装目录为 /root/cert 目录。\nx-ui 面板设置\n建议换掉默认端口\n配置SSL证书路径\n\n\n\n公钥文件路径：fullchain.cer 路径\n私钥文件路径：映射到此服务器的域名.key路径\n\n\n\n添加节点进入x-ui 面板，可视化添加节点。目前推荐 Vless+reality+tcp+xtls-rprx-vison 方案。\n注意事项：\n\n使用 reality 需要xray core版本为1.8.0及以上。请在面板切换xray-core版本，若出现error ，建议删除所有节点后重新切换。\n\n\n","categories":["工具"],"tags":["自建节点","v2ray","x-ui"]},{"title":"关于Pycharm块注释无法使用的问题","url":"/2023/06/18/tool/%E5%85%B3%E4%BA%8EPycharm%E5%9D%97%E6%B3%A8%E9%87%8A%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98/","content":"我们在使用Pycharm写 python 代码的时候会发现，块注释不管从菜单还是快捷键都是无法使用的。上网查了一下原因贴在这里：\n\n\n\nhttps://stackoverflow.com/a/42710582\nThe Code | “Comment with Block Comment” stays grayed out if pycharm does not know the syntax for adding comments for the particular file type. You can configure this in File | Settings, then select Editor&#x2F;File Type. Select the Recognized File type that you want to configure comments for, or add it if it does not exist.\n\n简而言之，就是Pycharm不知道 python 文件块注释的语法，所以不能使用。\n根据答主所说，你可以根据想要的文件类型进行配置注释。但Pycharm选中已有的File Type后，实际上是不能够编辑的。因此这种方式行不通。\n那么要想使用块注释，有以下方案：\n\n选中之后行注释( Ctrl + / )，快速对每行进行注释。\n手动使用 &#39;&#39;&#39; 或者 &quot;&quot;&quot;进行包裹。\n新建一种File Type，自定义它的block comment，显然太过繁琐。\n使用Live Template代码模板(推荐)\n\n新建代码模板：\n\nTemplate Text：\n&#x27;&#x27;&#x27;$START$&#x27;&#x27;&#x27;\n\n这样就可以使用 abbreviation+Tab 键快速生成块注释了。\n但Python应该是习惯于使用 # 作为注释，所以第一种方案就挺好的。我作为一个初学者，本文只是给出一个解决方案。\n","categories":["工具"],"tags":["Pycharm","Python"]}]